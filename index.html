<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Testing ThreeJS</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<div id="info">
			lovely sprites
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "/build/three.module.js"
				}
			}
		</script>

        <script src="/build/stats.min.js"></script>

		<script type="module">
			import * as THREE from '/build/three.module.js';
			
			import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
  			import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
  			import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js';

			var stats = new Stats();
			stats.showPanel(0); // Show FPS
			document.body.appendChild(stats.dom);

			let camera, scene, renderer, composer;
			let cameraOrtho, sceneOrtho;

			let instancedMesh;
			const radius = 625;
			const partNumber = 50000;
			const originalColors = [];

			let raycaster, mouse;

			init();

			function init() {
				const width = window.innerWidth;
				const height = window.innerHeight;

				
				// Perspective Camera (3D content)
				camera = new THREE.PerspectiveCamera(60, width / height, 1, 2100);
				camera.position.z = 1500;
				
				// Ortho Camera (2D HUD)
				cameraOrtho = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 1, 10);
				cameraOrtho.position.z = 10;
				
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog(0x000000, 1500, 2100);
				
				sceneOrtho = new THREE.Scene();
				
				// Basic material
				const material = new THREE.MeshStandardMaterial({
					color: 0xffffff,
					roughness: 0.3,
					metalness: 0
				});
				
				// Create basic geometry for instanced meshes
				const sphereGeometry = new THREE.SphereGeometry(0.35, 5, 5);
				instancedMesh = new THREE.InstancedMesh(sphereGeometry, material, partNumber);
				
				// Add instances
				const dummy = new THREE.Object3D(); // Dummy obj to create instances
				for (let i = 0; i < partNumber; i++) {
					const x = (Math.random() - 0.5) * 2;
					const y = (Math.random() - 0.5) * 2;
					const z = (Math.random() - 0.5) * 2;

					// Set instance position
					dummy.position.set(x, y, z);
					dummy.position.normalize();
					dummy.position.multiplyScalar(radius);

					// Random obj scale
					const scale = Math.random() * 10 + 15; // Dim. between 15 and 25
					dummy.scale.set(scale, scale, scale);

					// Update dummy and add to instanced matrix
					dummy.updateMatrix();
					instancedMesh.setMatrixAt(i, dummy.matrix);

					// Generate casual color (between cyan and purple)
					const hue = 0.5 + (0.45 * Math.random());
					const color = new THREE.Color().setHSL(hue, 0.8, 0.5);
					
					originalColors[i] = color.clone();

					// Set mesh color for the instance
					instancedMesh.setColorAt(i, color);
					instancedMesh.instanceColor.needsUpdate = true;
				}

				scene.add(instancedMesh);

				// Add ambient and directional light
				const ambientLight = new THREE.AmbientLight(0x888888, 2);
				scene.add(ambientLight);

				const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
				directionalLight.position.set(1, 1, 1).normalize();
				scene.add(directionalLight);

				// Renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor(0x010101, 1);
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setAnimationLoop(animate);
				renderer.autoClear = false;

				document.body.appendChild(renderer.domElement);

				// Post-processing for glow effect
				const renderPass = new RenderPass(scene, camera);
				const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
				bloomPass.threshold = 0.18;
				bloomPass.strength = 7.5; // Glow intencity
				bloomPass.radius = 0.8;

				composer = new EffectComposer(renderer);
				composer.addPass(renderPass);
				composer.addPass(bloomPass);

				window.addEventListener('resize', onWindowResize);
				window.addEventListener('mousemove', onMouseMove);

				// Init raycaster and mouse
				raycaster = new THREE.Raycaster();
				raycaster.near = 0.1;
				raycaster.far = 10000;
				mouse = new THREE.Vector2();
			}

			function onMouseMove(event) {
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			}

			function onWindowResize() {
				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				cameraOrtho.left = - width / 2;
				cameraOrtho.right = width / 2;
				cameraOrtho.top = height / 2;
				cameraOrtho.bottom = - height / 2;
				cameraOrtho.updateProjectionMatrix();

				composer.setSize(width, height);
				renderer.setSize(width, height);
			}

			function animate() {
				stats.begin();

				const time = Date.now() / 1000;

				// Animate group rotation
				instancedMesh.rotation.x = time * 0.5;
				instancedMesh.rotation.y = time * 0.75;
				instancedMesh.rotation.z = time * 1.0;

				camera.position.z = 1500 + Math.sin(time) * 130;

				// Raycaster handling
				raycaster.setFromCamera(mouse, camera);
				const intersects = raycaster.intersectObject(instancedMesh);

				const intersectedIds = new Set(intersects.map(intersect => intersect.instanceId));

				// Change color to white for object hit by ray
				//console.log(intersects.length);
				for (let i = 0; i < intersects.length; i++) {
					const instanceId = intersects[i].instanceId;
					if (instanceId !== undefined) {
						const color = new THREE.Color().setHSL(1, 1, 1); // Highlight color
						instancedMesh.setColorAt(instanceId, color);
						instancedMesh.instanceColor.needsUpdate = true;
					}
				}

				// Restore default color for spheres that are not hit by the ray
				// TODO: maybe use an array to store the indexes of the hit sphere and cycle only on those to improve rendering
				for (let i = 0; i < partNumber; i++) {
					if (!intersectedIds.has(i)) {
						const originalColor = originalColors[i];
						instancedMesh.setColorAt(i, originalColor); // Restore 
						instancedMesh.instanceColor.needsUpdate = true;
					}
				}

				// Use the composer for the bloom effect
				composer.render();

				stats.end();
			}
		</script>

		  
		  
	</body>
</html>