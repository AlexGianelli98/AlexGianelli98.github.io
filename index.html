<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Testing ThreeJS</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<div id="info">
			lovely sprites
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "/build/three.module.js"
				}
			}
		</script>

        <script src="/build/stats.min.js"></script>

		<script type="module">
			import * as THREE from '/build/three.module.js';
			
			import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
  			import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
  			import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js';

			import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/FontLoader.js';
      		import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/geometries/TextGeometry.js';


			var stats = new Stats();
			stats.showPanel(0); // Show FPS
			document.body.appendChild(stats.dom);

			let camera, scene, renderer, composer;
			let cameraOrtho, sceneOrtho;

			let raycaster, mouse;

			let textMesh, textMaterial;

			let instancedMesh;
			const radius = 625;
			const partNumber = 100000;
			let originalColors = [];
			let highlighterSpheres = [];

			init();

			function init() {
				const width = window.innerWidth;
				const height = window.innerHeight;
				
				// Perspective Camera (3D content)
				camera = new THREE.PerspectiveCamera(60, width / height, 1, 2100);
				camera.position.z = 1500;
				
				// Ortho Camera (2D HUD)
				cameraOrtho = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 1, 10);
				cameraOrtho.position.z = 10;
				
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog(0x000000, 1500, 2100);
				
				sceneOrtho = new THREE.Scene();

				// Add the text to the sceneOrtho (UI)
				const fontLoader = new FontLoader();
				fontLoader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function (font) {
					const textGeometry = new TextGeometry('Home', {
						font: font,
						size: 92,
						height: 5,
						curveSegments: 20,
					});
					textGeometry.computeBoundingBox();
  
					// Center the textMesh using the bounding box
					const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
					textGeometry.translate(centerOffset, 0, 0); // Apply the offset directly to the geometry

					const textMaterial = new THREE.MeshBasicMaterial({ color: 0xcc00cc });
					textMesh = new THREE.Mesh(textGeometry, textMaterial);
					textMesh.position.set(0, 0, 1); // Keep the position centered
					sceneOrtho.add(textMesh);
				});
				
				// Basic material
				const material = new THREE.MeshStandardMaterial({
					color: 0xffffff,
					roughness: 0.3,
					metalness: 0
				});
				
				// Create basic geometry for instanced meshes
				const sphereGeometry = new THREE.SphereGeometry(0.35, 5, 5);
				instancedMesh = new THREE.InstancedMesh(sphereGeometry, material, partNumber);
				
				// Add instances
				const dummy = new THREE.Object3D(); // Dummy obj to create instances
				for (let i = 0; i < partNumber; i++) {
					const x = (Math.random() - 0.5) * 2;
					const y = (Math.random() - 0.5) * 2;
					const z = (Math.random() - 0.5) * 2;

					// Set instance position
					dummy.position.set(x, y, z);
					dummy.position.normalize();
					dummy.position.multiplyScalar(radius);

					// Random obj scale
					const scale = Math.random() * 10 + 15; // Dim. between 15 and 25
					dummy.scale.set(scale, scale, scale);

					// Update dummy and add to instanced matrix
					dummy.updateMatrix();
					instancedMesh.setMatrixAt(i, dummy.matrix);

					// Generate casual color (between cyan and purple)
					const hue = 0.5 + (0.45 * Math.random());
					const color = new THREE.Color().setHSL(hue, 0.8, 0.5);
					
					originalColors[i] = color.clone();

					// Set mesh color for the instance
					instancedMesh.setColorAt(i, color);
					instancedMesh.instanceColor.needsUpdate = true;
				}

				scene.add(instancedMesh);

				// Add ambient and directional light
				const ambientLight = new THREE.AmbientLight(0x888888, 2);
				scene.add(ambientLight);

				const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
				directionalLight.position.set(1, 1, 1).normalize();
				scene.add(directionalLight);

				// Renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor(0x010101, 1);
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setAnimationLoop(animate);
				renderer.autoClear = false;

				document.body.appendChild(renderer.domElement);

				// Post-processing for glow effect
				const renderPass = new RenderPass(scene, camera);
				const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
				bloomPass.threshold = 0.18;
				bloomPass.strength = 7.5; // Glow intencity
				bloomPass.radius = 0.8;

				composer = new EffectComposer(renderer);
				composer.addPass(renderPass);
				composer.addPass(bloomPass);

				window.addEventListener('resize', onWindowResize);
				window.addEventListener('mousemove', onMouseMove);

				// Init raycaster and mouse
				raycaster = new THREE.Raycaster();
				raycaster.near = 0.1;
				raycaster.far = 10000;
				raycaster.params.Mesh.threshold = 0.5;
				mouse = new THREE.Vector2();
			}

			function onMouseMove(event) {
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			}

			function onWindowResize() {
				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				cameraOrtho.left = - width / 2;
				cameraOrtho.right = width / 2;
				cameraOrtho.top = height / 2;
				cameraOrtho.bottom = - height / 2;
				cameraOrtho.updateProjectionMatrix();

				composer.setSize(width, height);
				renderer.setSize(width, height);
			}

			function animate() {
				stats.begin();

				const time = Date.now() / 1000;

				// Animate group rotation
				instancedMesh.rotation.x = time * 0.5;
				instancedMesh.rotation.y = time * 0.75;
				instancedMesh.rotation.z = time * 1.0;

				camera.position.z = 1500 + Math.sin(time) * 130;

				// Raycaster handling
				raycaster.setFromCamera(mouse, camera);
				const intersectsMeshes = raycaster.intersectObject(instancedMesh);

				const intersectedIds = new Set(intersectsMeshes.map(intersect => intersect.instanceId));

				// Change color to white for object hit by ray
				for (let i = 0; i < intersectsMeshes.length; i++) {
					const instanceId = intersectsMeshes[i].instanceId;
					if (instanceId !== undefined) {
						const color = new THREE.Color().setHSL(1, 1, 1); // Highlight color
						instancedMesh.setColorAt(instanceId, color);
						instancedMesh.instanceColor.needsUpdate = true;

						if (!highlighterSpheres.includes(instanceId)) {
							highlighterSpheres.push(instanceId);
						}
					}
				}

				// Restore default color for spheres that are not hit by the ray
				// Use highlightedSpheres array to improve performance
				for (let j = highlighterSpheres.length -1; j >= 0; j--) {
					const instanceId = highlighterSpheres[j];
					if (!intersectedIds.has(instanceId)) {
						const originalColor = originalColors[instanceId];

						instancedMesh.setColorAt(instanceId, originalColor); // Restore 
						instancedMesh.instanceColor.needsUpdate = true;

						highlighterSpheres.splice(j, 1);
					}
				}

				if (textMesh) {
					/*
					const intersectsText = raycaster.intersectObject(textMesh);
					if (intersectsText.length > 0) {
						textMesh.material.color.set(0x0000ff); // Set color to blue
					} else {
						textMesh.material.color.set(0xff0000); // Set color back to red
					}
					*/
				}
				
				
				// Use the composer for the bloom effect
				composer.render();

				renderer.clearDepth(); // Clear depth buffer for the UI
				renderer.render(sceneOrtho, cameraOrtho); // Render UI scene

				stats.end();
			}
		</script>
		  
	</body>
</html>